## SQL 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기(5분 소요)
- %LIKE%를 활용해 풀 테이블 스캔으로 문제를 해결하였습니다.

## 1449 수리공 항승(55분 소요)
- 중복해서 막을 수 있다는 말에서 끝을 넘으면 안된다 생각했고, 자연스레 투포인터로 접근하였습니다.
- end 시점에 counting을 했더니, start와 end에서 조건을 양쪽으로 신경써줘야 했고, 알고리즘 구현이 까다로워 새로 풀기로 했습니다.
- start 시점에 counting을 하는 방법으로 문제를 해결하였습니다.
- 위 방식은 그리디로 접근하였고, start 시점에서 limit범위를 넘을 때 까지 반복하고, 최초로 넘는 시점에 counting을 하고 limit를 갱신해주는 행위를 반복하며 문제를 해결하였습니다.

## 14620 꽃길(30분 소요)
- 씨앗이 3개로 고정된걸 확인 후, 3중 for 문을 이용하기로 하였습니다. (실제로는 x,y좌표 따로 했기에 6중 for문)
- n의 격자 최대 크기는 10*10 이므로 3중 for문을 적용 했을 때, 시간복잡도가 최대 1백만이여서 그대로 진행했습니다.
- 죽는 조건
  1. 꽃잎이 겹치면 (3중 for문의 범위 조정으로 해결)
  2. 격자 밖으로 나가면 (visited 배열을 이용)
- 3개의 씨앗이 모두 만개한다면, 해당 임대값을 구하고, 최댓 값인지 비교 후 갱신하는 로직을 적용하였습니다.

## 2116 주사위 쌓기(30분 소요)
- 해당 문제는 첫번째 주사위의 bottom 설정 값에 따라 총 나올 수 있는 6가지의 경우(중복 제거하면 3가지) 중 가장 최댓값을 구하면 되는 문제입니다.
- 첫번째 bottom이 결정되면,
  - 첫번째의 bottom -> 첫번째의 top 결정 -> 두번째의 bottom -> 두번째의 top -> 세번째의 bottom -> ... -> n번째의 top
- 또한, 주사위를 쌓고나면, side는 마음대로 배치가 가능하기에, top,bottom을 제외한 최댓값을 뽑으면 됩니다.
- 알고리즘 분석 후, Dice 클래스를 만들어서 위 문제를 풀어나감
- Dice에는 A,B,C,D,E,F의 멤버 변수가 있고, top <-> bottom을 변환하는 convert(), 정해진 bottom일 때, 최대 side를 뽑을 수 있는 maxSideByBottom() 으로 구성되어있음
- 위 객체를 바탕으로 위 알고리즘을 적용해서 해당 문제 해결

## 피드백 내용
- Scanner 대신 bufferedReader 이용해보기
- 고차함수 적용해보기